.data
dataARR1 dd 13, 655, 12, -20, -8, 5, 18 ; Початковий масив
dataRESULT1 dw 7 DUP(0) ; Перший масив результатів (старше слово)
dataRESULT2 dw 7 DUP(0) ; Другий масив результатів (молодше слово)

.code
entry_point proc
    lea R8, dataARR1 ; Завантажуємо адресу початкового масиву в регістр R8
    lea RBX, dataRESULT1 ; Завантажуємо адресу першого масиву результатів (старше слово) в регістр RBX
    lea RDI, dataRESULT2 ; Завантажуємо адресу другого масиву результатів (молодше слово) в регістр RDI

    mov RCX, 7 ; Кількість елементів у масиві

loopa:
    mov EAX, [R8] ; Завантажуємо елемент початкового масиву в регістр EAX
    sal EAX, 3 ; Зсуваємо вліво арифметично на 3 біти
    mov [RBX], AX ; Записуємо результат в перший масив результатів (старше слово)
    shr EAX, 16 ; Переносимо молодше слово до молодшої частини регістру
    mov [RDI], AX ; Записуємо результат в другий масив результатів (молодше слово)
    add R8, 4 ; Переходимо до наступного елемента початкового масиву
    add RBX, 2 ; Переходимо до наступного елемента першого масиву результатів (старше слово)
    add RDI, 2 ; Переходимо до наступного елемента другого масиву результатів (молодше слово)
    loop loopa ; Повторюємо цикл для кожного елемента масиву

; Перевірка на більше D5h у першому і другому масиві
    lea R9, dataRESULT1
    lea R16, dataRESULT2
    mov RCX, 7 ; Кількість елементів у кожному масиві результатів

check:
    mov AX, [R9]
    cmp AX, 0D5h
    jbe less_equal_D5h ; Перевіряємо, чи елемент менший або рівний за D5h
    mov word ptr [R9], 0 ; Якщо більше D5h, записуємо 0

less_equal_D5h:
    mov AX, [R16]
    cmp AX, 0D5h
    jbe continue_check ; Перевіряємо, чи елемент менший або рівний за D5h
    mov word ptr [R16], 0 ; Якщо більше D5h, записуємо 0

continue_check:
    add R9, 2
    add R10, 2
    loop check

ret
entry_point endp
end
